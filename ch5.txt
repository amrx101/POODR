http://pdf.th7.cn/down/files/1502/Practical%20Object-Oriented%20Design%20in%20Ruby.pdf
CHAPTER 5
Reducing Costs with Duck Typing - QUACK!!!


1) Reducing Costs with Duck Typing 85
The purpose of OOD is to reduce the cost of change.
Messages are at the design center.
As is constructing rigorous PUBLIC interfaces.
Combine these two ideas into a technique known as DUCK TYPING.
Not "typing" like at a keyboard, but determining a "TYPE"
DUCK-TYPES are PUBLIC interface that aren't tied to a specific class. They are
across-class interfaces and replace dependency on class with dependency on messages



2) Understanding Duck Typing 85
Types e.g. strings, numbers, arrays, Booleans, etc... the category of contents of
a variable(generally used to describe data). Knowledge of the variables type allows
the application to have an expectation about how those contents will behave.
In Ruby, knowing an objects type is knowing which messages that object will respond to.


2a) Overlooking the Duck 87
(see ch5a.rb & figure 5.1)
This is also an example of f4.6 in Ch.4.


2b) Compounding the Problem 87
(see ch5b.rb and figure 5.2)
This dependent-laden code will back you in a corner with no way out.
Adding a "case" statement that switches on class solves the problem of sending
the correct message to the correct object but causes an explosion of dependencies.
Sequence diagrams should ALWAYS be simpler than the code they represent.


2c) Finding the Duck 90
(see ch5c.rb)

2d) Consequences of Duck Typing 94


2d.1) POLYMORPHISM



3) Writing Code That Relies on Ducks 95


3a) Recognizing Hidden Ducks 96


3b) Placing Trust in Your Ducks 98


3c) Documenting Duck Types 98


3d) Sharing Code Between Ducks 99


3e) Choosing Your Ducks Wisely 99



4) Conquering a Fear of Duck Typing 100


4a) Subverting Duck Types with Static Typing 100


4b) Static versus Dynamic Typing 101


4c) Embracing Dynamic Typing 102



5) Summary 104


